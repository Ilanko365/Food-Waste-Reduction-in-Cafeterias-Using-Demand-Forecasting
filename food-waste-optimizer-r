# =============================================
# Food Waste Reduction in Cafeterias
# Shiny Front-end for Forecast + Newsvendor Optimization
# =============================================

library(shiny)
library(tidyverse)
library(lubridate)
library(forecast)
library(randomForest)

# ---- Source your backend function ----
# Put your forecast_newsvendor definition here (from your backend code)
forecast_newsvendor <- function(df, h, cost_overage, cost_under) {
  # Ensure proper order
  df <- df %>% arrange(date)
  
  # Pick demand column
  series <- df$demand
  
  # Forecast demand
  fit <- forecast::auto.arima(ts(series, frequency = 7))
  fc <- forecast::forecast(fit, h = h)
  forecasts <- as.numeric(fc$mean)
  
  # --- Newsvendor critical fractile logic ---
  p <- cost_under / (cost_under + cost_overage)  # service level
  optimal_q <- qnorm(p, mean = forecasts, sd = sd(series, na.rm = TRUE))
  
  tibble(
    date = seq.Date(max(df$date) + 1, by = "day", length.out = h),
    Forecast = forecasts,
    Optimal_Production = pmax(round(optimal_q), 0)
  )
}


# =============================================
# UI
# =============================================
library(shinythemes)
library(shinyWidgets)   # for pretty buttons/cards
ui <- fluidPage(
  
  theme = shinytheme("flatly"),   # Modern theme
  
  # ---- Header ----
  titlePanel(div("🍽️ Cafeteria Food Waste Reduction Dashboard",
                 style = "font-weight: bold; font-size: 28px; color: #2C3E50;")),
  br(),
  
  # ---- Summary Info Cards ----
  fluidRow(
    column(3,
           wellPanel(
             style="background-color:#EAF2F8; border-radius:12px; text-align:center;",
             h4("🏢 Cafeterias"),
             textOutput("caf_count"),
             style="font-size:18px; font-weight:bold; color:#2C3E50;"
           )),
    column(3,
           wellPanel(
             style="background-color:#FEF9E7; border-radius:12px; text-align:center;",
             h4("🥗 Items"),
             textOutput("item_count"),
             style="font-size:18px; font-weight:bold; color:#2C3E50;"
           )),
    column(3,
           wellPanel(
             style="background-color:#E8F8F5; border-radius:12px; text-align:center;",
             h4("⏳ Forecast Horizon"),
             textOutput("horizon_days"),
             style="font-size:18px; font-weight:bold; color:#2C3E50;"
           )),
    column(3,
           wellPanel(
             style="background-color:#FDEDEC; border-radius:12px; text-align:center;",
             h4("📅 Last Upload"),
             textOutput("last_upload"),
             style="font-size:18px; font-weight:bold; color:#2C3E50;"
           ))
  ),
  br(),
  
  # ---- Main Layout ----
  sidebarLayout(
    sidebarPanel(
      style = "background-color: #F9F9F9; border-radius: 12px; padding: 20px;",
      
      h4("⚙️ Configuration", style="color:#2C3E50; font-weight:bold;"),
      hr(),
      
      fileInput("file", "📂 Upload Cafeteria Sales CSV", accept = c(".csv")),
      numericInput("horizon", "⏳ Forecast horizon (days):", 14, min=7, max=60),
      numericInput("cost_over", "💸 Overage cost per unit:", 2, min=0),
      numericInput("cost_under", "📉 Underage cost per unit:", 8, min=0),
      
      br(),
      actionBttn("run", "Run Forecast & Optimization",
                 style = "gradient", color = "success", size = "lg", block = TRUE),
      br(),
      downloadBttn("downloadData", "Download Forecast CSV",
                   style = "gradient", color = "primary", block = TRUE)
    ),
    
    mainPanel(
      tabsetPanel(type="pills",
                  tabPanel("📊 Forecast Table", 
                           br(),
                           tableOutput("table")),
                  
                  tabPanel("📈 Chart", 
                           br(),
                           plotOutput("plot", height="600px"))
      )
    )
  )
)


# =============================================
# SERVER
# =============================================
server <- function(input, output, session) {
  
  # Helper: safe forecast per group - guarantees h rows and a date column
  safe_forecast_group <- function(df, h, cost_overage, cost_under) {
    df <- df %>% arrange(date)
    # Try calling user function
    out <- tryCatch(
      forecast_newsvendor(df, h = as.integer(h), cost_overage = cost_overage, cost_under = cost_under),
      error = function(e) NULL,
      warning = function(w) tryCatch(forecast_newsvendor(df, h = as.integer(h), cost_overage = cost_overage, cost_under = cost_under), error = function(e) NULL)
    )
    
    # If returned object is not a data.frame, build fallback forecast
    if (is.null(out) || !is.data.frame(out)) {
      # pick a numeric series column to forecast (prefer common names)
      possible_names <- c("demand", "sales", "quantity", "qty", "count", "value")
      lower_names <- tolower(names(df))
      pick_name <- names(df)[which(lower_names %in% possible_names)[1]]
      if (is.na(pick_name)) {
        numeric_cols <- df %>% select(where(is.numeric))
        pick_name <- if (ncol(numeric_cols) > 0) names(numeric_cols)[1] else NULL
      }
      series <- if (!is.null(pick_name)) df[[pick_name]] else NULL
      
      if (!is.null(series) && length(na.omit(series)) >= 2) {
        # try an ARIMA forecast (weekly frequency to capture weekday effects)
        ts_series <- tryCatch(ts(series, frequency = 7), error = function(e) ts(series))
        fit <- tryCatch(forecast::auto.arima(ts_series), error = function(e) NULL)
        if (!is.null(fit)) fc <- tryCatch(forecast::forecast(fit, h = as.integer(h)), error = function(e) list(mean = rep(mean(series, na.rm = TRUE), as.integer(h)))) else fc <- list(mean = rep(mean(series, na.rm = TRUE), as.integer(h)))
        fc_vals <- as.numeric(fc$mean)
        last_date <- max(df$date, na.rm = TRUE)
        out <- tibble(
          date = seq.Date(last_date + 1, by = "day", length.out = as.integer(h)),
          Forecast = fc_vals,
          Optimal_Production = round(fc_vals)
        )
      } else {
        # can't compute a numeric forecast — return NA rows for h
        last_date <- max(df$date, na.rm = TRUE)
        out <- tibble(
          date = seq.Date(last_date + 1, by = "day", length.out = as.integer(h)),
          Forecast = rep(NA_real_, as.integer(h)),
          Optimal_Production = rep(NA_real_, as.integer(h))
        )
      }
    } else {
      # Ensure there's a date column and it is Date type
      if (!"date" %in% names(out)) {
        last_date <- max(df$date, na.rm = TRUE)
        out <- out %>% mutate(date = seq.Date(last_date + 1, by = "day", length.out = nrow(out)))
      } else {
        out <- out %>% mutate(date = as.Date(date))
      }
      
      # Pad or trim to exactly h rows
      if (nrow(out) < as.integer(h)) {
        missing <- as.integer(h) - nrow(out)
        last_date <- max(out$date, na.rm = TRUE)
        pad <- tibble(
          date = seq.Date(last_date + 1, by = "day", length.out = missing),
          Forecast = rep(if ("Forecast" %in% names(out)) tail(out$Forecast, 1) else NA_real_, missing),
          Optimal_Production = rep(if ("Optimal_Production" %in% names(out)) tail(out$Optimal_Production, 1) else NA_real_, missing)
        )
        out <- bind_rows(out, pad)
      } else if (nrow(out) > as.integer(h)) {
        out <- out %>% slice_head(n = as.integer(h))
      }
    }
    
    # final guard: ensure columns Forecast and Optimal_Production exist
    if (!"Forecast" %in% names(out)) out$Forecast <- NA_real_
    if (!"Optimal_Production" %in% names(out)) out$Optimal_Production <- NA_real_
    
    out
  }
  
  
  results <- eventReactive(input$run, {
    req(input$file)
    
    # Robust date parsing: handles numeric (Excel/epoch-like) or common string formats
    raw <- read_csv(input$file$datapath, guess_max = 10000) %>%
      mutate(date = case_when(
        # if column stored as numeric days (e.g. 19723), treat as days since 1970-01-01
        is.numeric(date) ~ as.Date(date, origin = "1970-01-01"),
        # otherwise try parsing common formats
        TRUE ~ as.Date(parse_date_time(as.character(date),
                                       orders = c("Ymd", "Y-m-d", "d/m/Y", "m/d/Y", "Ymd HMS", "Y-m-d H:M:S")), tz = "UTC")
      ))
    
    # Group by cafeteria & item, compute forecasts with safe wrapper
    res <- raw %>%
      group_by(cafeteria, item) %>%
      group_modify(~ safe_forecast_group(.x, h = input$horizon, cost_overage = input$cost_over, cost_under = input$cost_under)) %>%
      ungroup() %>%
      arrange(date, cafeteria, item, Forecast) %>%
      # put date first, then cafeteria, item, then everything else
      select(date, cafeteria, item, everything())
    
    return(res)
  })
  
  
  # ---- Info cards outputs (keep these) ----
  output$caf_count <- renderText({
    if (is.null(input$file)) return("-")
    # protect: results() may be null until run
    df <- results()
    if (is.null(df) || nrow(df) == 0) return("0")
    length(unique(df$cafeteria))
  })
  
  output$item_count <- renderText({
    if (is.null(input$file)) return("-")
    df <- results()
    if (is.null(df) || nrow(df) == 0) return("0")
    length(unique(df$item))
  })
  
  output$horizon_days <- renderText({
    input$horizon
  })
  
  output$last_upload <- renderText({
    if (is.null(input$file)) return("-")
    format(Sys.Date(), "%Y-%m-%d")
  })
  
  
  # ---- Table, Plot, Download ----
  output$table <- renderTable({
    head(results() %>%
           mutate(date = format(date, "%Y-%m-%d")), 20)
  }, striped = TRUE, spacing = "m")
  
  output$plot <- renderPlot({
    req(results())
    df <- results()
    # ensure date is Date for plotting
    df <- df %>% mutate(date = as.Date(date))
    ggplot(df, aes(x = date)) +
      geom_line(aes(y = Forecast, color = "Forecast")) +
      geom_line(aes(y = Optimal_Production, color = "Optimal Production")) +
      facet_wrap(~ cafeteria + item, scales = "free_y") +
      theme_minimal() +
      labs(color = "", x = "Date")
  })
  
  output$downloadData <- downloadHandler(
    filename = function() {
      paste0("forecast_newsvendor_", Sys.Date(), ".csv")
    },
    content = function(file) {
      write_csv(results(), file)
    }
  )
}


# =============================================
# Run the Shiny App
# =============================================
shinyApp(ui, server)
